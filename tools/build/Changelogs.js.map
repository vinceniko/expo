{"version":3,"file":"Changelogs.js","sourceRoot":"","sources":["../src/Changelogs.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport semver from 'semver';\nimport semverRegex from 'semver-regex';\n\nimport * as Markdown from './Markdown';\nimport { execAll } from './Utils';\n\n/**\n * Type of the objects representing single changelog entry.\n */\nexport type ChangelogEntry = {\n  /**\n   * The change note.\n   */\n  message: string;\n  /**\n   * The pull request number.\n   */\n  pullRequests?: number[];\n  /**\n   * GitHub's user names of someones who made this change.\n   */\n  authors?: string[];\n};\n\n/**\n * Describes changelog entries under specific version.\n */\nexport type ChangelogVersionChanges = Record<ChangeType, ChangelogEntry[]>;\n\n/**\n * Type of the objects representing changelog entries.\n */\nexport type ChangelogChanges = {\n  totalCount: number;\n  versions: Record<string, ChangelogVersionChanges>;\n};\n\n/**\n * Represents options object that can be passed to `insertEntriesAsync`.\n */\nexport type InsertOptions = Partial<{\n  unshift: boolean;\n}>;\n\n/**\n * Enum with changelog sections that are commonly used by us.\n */\nexport enum ChangeType {\n  LIBRARY_UPGRADES = 'üìö 3rd party library updates',\n  BREAKING_CHANGES = 'üõ† Breaking changes',\n  NEW_FEATURES = 'üéâ New features',\n  BUG_FIXES = 'üêõ Bug fixes',\n  NOTICES = '‚ö†Ô∏è Notices',\n}\n\n/**\n * Heading name for unpublished changes.\n */\nexport const UNPUBLISHED_VERSION_NAME = 'Unpublished';\n\nexport const VERSION_EMPTY_PARAGRAPH_TEXT =\n  '_This version does not introduce any user-facing changes._\\n';\n\n/**\n * Depth of headings that mean the version containing following changes.\n */\nconst VERSION_HEADING_DEPTH = 2;\n\n/**\n * Depth of headings that are being recognized as the type of changes (breaking changes, new features of bugfixes).\n */\nconst CHANGE_TYPE_HEADING_DEPTH = 3;\n\n/**\n * Depth of the list that can be a group.\n */\nconst GROUP_LIST_ITEM_DEPTH = 0;\n\n/**\n * Class representing a changelog.\n */\nexport class Changelog {\n  filePath: string;\n  tokens: Markdown.Tokens | null = null;\n\n  constructor(filePath: string) {\n    this.filePath = filePath;\n  }\n\n  /**\n   * Resolves to `true` if changelog file exists, `false` otherwise.\n   */\n  async fileExistsAsync(): Promise<boolean> {\n    return await fs.pathExists(this.filePath);\n  }\n\n  /**\n   * Lexifies changelog content and returns resulting tokens.\n   */\n  async getTokensAsync(): Promise<Markdown.Tokens> {\n    if (!this.tokens) {\n      try {\n        const markdown = await fs.readFile(this.filePath, 'utf8');\n        this.tokens = Markdown.lexify(markdown);\n      } catch (error) {\n        this.tokens = [];\n      }\n    }\n    return this.tokens;\n  }\n\n  /**\n   * Reads versions headers, collects those versions and returns them.\n   */\n  async getVersionsAsync(): Promise<string[]> {\n    const tokens = await this.getTokensAsync();\n\n    return tokens\n      .filter((token): token is Markdown.HeadingToken => isVersionToken(token))\n      .map((token) => parseVersion(token.text))\n      .filter(Boolean) as string[];\n  }\n\n  /**\n   * Returns the last version in changelog.\n   */\n  async getLastPublishedVersionAsync(): Promise<string | null> {\n    const versions = await this.getVersionsAsync();\n    return versions.find((version) => semver.valid(version)) ?? null;\n  }\n\n  /**\n   * Reads changes between two given versions and returns them in JS object format.\n   * If called without params, then only unpublished changes are returned.\n   */\n  async getChangesAsync(\n    fromVersion?: string,\n    toVersion: string = UNPUBLISHED_VERSION_NAME\n  ): Promise<ChangelogChanges> {\n    const tokens = await this.getTokensAsync();\n    const versions: ChangelogChanges['versions'] = {};\n    const changes: ChangelogChanges = { totalCount: 0, versions };\n\n    let currentVersion: string | null = null;\n    let currentSection: string | null = null;\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (Markdown.isHeadingToken(token)) {\n        if (token.depth === VERSION_HEADING_DEPTH) {\n          const parsedVersion = parseVersion(token.text);\n\n          if (!parsedVersion) {\n            // Token is not a valid version token.\n            continue;\n          }\n          if (parsedVersion !== toVersion && (!fromVersion || parsedVersion === fromVersion)) {\n            // We've iterated over everything we needed, stop the loop.\n            break;\n          }\n\n          currentVersion = parsedVersion;\n          currentSection = null;\n\n          if (!versions[currentVersion]) {\n            versions[currentVersion] = {} as ChangelogVersionChanges;\n          }\n        } else if (currentVersion && token.depth === CHANGE_TYPE_HEADING_DEPTH) {\n          currentSection = token.text;\n\n          if (!versions[currentVersion][currentSection]) {\n            versions[currentVersion][currentSection] = [];\n          }\n        }\n        continue;\n      }\n\n      if (currentVersion && currentSection && Markdown.isListToken(token)) {\n        for (const item of token.items) {\n          const text = item.tokens.find(Markdown.isTextToken)?.text ?? item.text;\n\n          changes.totalCount++;\n          versions[currentVersion][currentSection].push(textToChangelogEntry(text));\n        }\n      }\n    }\n    return changes;\n  }\n\n  /**\n   * Saves changes that we made in the array of tokens.\n   */\n  async saveAsync(): Promise<void> {\n    // If tokens where not loaded yet, there is nothing to save.\n    if (!this.tokens) {\n      return;\n    }\n\n    // Parse cached tokens and write result to the file.\n    await fs.outputFile(this.filePath, Markdown.render(this.tokens));\n\n    // Reset cached tokens as we just modified the file.\n    // We could use an array with new tokens here, but just for safety, let them be reloaded.\n    this.tokens = null;\n  }\n\n  /**\n   * Inserts given entries under specific version, change type and group.\n   * Returns a new array of entries that were successfully inserted (filters out duplicated entries).\n   * Throws an error if given version cannot be find in changelog.\n   */\n  async insertEntriesAsync(\n    version: string,\n    type: ChangeType | string,\n    group: string | null,\n    entries: (ChangelogEntry | string)[],\n    options: InsertOptions = {}\n  ): Promise<ChangelogEntry[]> {\n    if (entries.length === 0) {\n      return [];\n    }\n\n    const tokens = await this.getTokensAsync();\n    const sectionIndex = tokens.findIndex((token) => isVersionToken(token, version));\n\n    if (sectionIndex === -1) {\n      throw new Error(`Version ${version} not found.`);\n    }\n\n    for (let i = sectionIndex + 1; i < tokens.length; i++) {\n      if (isVersionToken(tokens[i])) {\n        // Encountered another version - so given change type isn't in changelog yet.\n        // We create appropriate change type token and insert this version token.\n        const changeTypeToken = Markdown.createHeadingToken(type, CHANGE_TYPE_HEADING_DEPTH);\n        tokens.splice(i, 0, changeTypeToken);\n        // `tokens[i]` is now `changeTypeToken` - so we will jump into `if` below.\n      }\n      if (isChangeTypeToken(tokens[i], type)) {\n        const changeTypeToken = tokens[i] as Markdown.HeadingToken;\n        let list: Markdown.ListToken | null = null;\n        let j = i + 1;\n\n        // Find the first list token between headings and save it under `list` variable.\n        for (; j < tokens.length; j++) {\n          const item = tokens[j];\n          if (Markdown.isListToken(item)) {\n            list = item;\n            break;\n          }\n          if (Markdown.isHeadingToken(item) && item.depth <= changeTypeToken.depth) {\n            break;\n          }\n        }\n\n        // List not found, create new list token and insert it in place where the loop stopped.\n        if (!list) {\n          list = Markdown.createListToken();\n          tokens.splice(j, 0, list);\n        }\n\n        // If group name is specified, let's go deeper and find (or create) a list for that group.\n        if (group) {\n          list = findOrCreateGroupList(list, group);\n        }\n\n        const addedEntries: ChangelogEntry[] = [];\n\n        // Iterate over given entries and push them to the list we ended up with.\n        for (const entry of entries) {\n          const entryObject = typeof entry === 'string' ? { message: entry } : entry;\n          const listItemLabel = getChangeEntryLabel(entryObject);\n\n          // Filter out duplicated entries.\n          if (!list.items.some((item) => item.text.trim() === listItemLabel.trim())) {\n            const listItem = Markdown.createListItemToken(\n              listItemLabel,\n              group ? GROUP_LIST_ITEM_DEPTH : 0\n            );\n\n            if (options.unshift) {\n              list.items.unshift(listItem);\n            } else {\n              list.items.push(listItem);\n            }\n            addedEntries.push(entryObject);\n          }\n        }\n        return addedEntries;\n      }\n    }\n    throw new Error(`Cound't find '${type}' section.`);\n  }\n\n  /**\n   * Renames header of unpublished changes to given version and adds new section with unpublished changes on top.\n   */\n  async cutOffAsync(\n    version: string,\n    types: string[] = [ChangeType.BREAKING_CHANGES, ChangeType.NEW_FEATURES, ChangeType.BUG_FIXES]\n  ): Promise<void> {\n    const tokens = await this.getTokensAsync();\n    const firstVersionHeadingIndex = tokens.findIndex((token) => isVersionToken(token));\n    const newSectionTokens = [\n      Markdown.createHeadingToken(UNPUBLISHED_VERSION_NAME, VERSION_HEADING_DEPTH),\n      ...types.map((type) => Markdown.createHeadingToken(type, CHANGE_TYPE_HEADING_DEPTH)),\n    ];\n\n    if (firstVersionHeadingIndex !== -1) {\n      // Set version of the first found version header and put current date in YYYY-MM-DD format.\n      const dateStr = new Date().toISOString().substring(0, 10);\n      (tokens[firstVersionHeadingIndex] as Markdown.HeadingToken).text = `${version} ‚Äî ${dateStr}`;\n\n      // Clean up empty sections.\n      let i = firstVersionHeadingIndex + 1;\n      while (i < tokens.length && !isVersionToken(tokens[i])) {\n        // Remove change type token if its section is empty - when it is followed by another heading token.\n        if (isChangeTypeToken(tokens[i])) {\n          const nextToken = tokens[i + 1];\n          if (!nextToken || isChangeTypeToken(nextToken) || isVersionToken(nextToken)) {\n            tokens.splice(i, 1);\n            continue;\n          }\n        }\n        i++;\n      }\n\n      // `i` stayed the same after removing empty change type sections, so the entire version is empty.\n      // Let's put an information that this version doesn't contain any user-facing changes.\n      if (i === firstVersionHeadingIndex + 1) {\n        tokens.splice(i, 0, {\n          type: Markdown.TokenType.PARAGRAPH,\n          text: VERSION_EMPTY_PARAGRAPH_TEXT,\n        });\n      }\n    }\n\n    // Insert new tokens before first version header.\n    tokens.splice(firstVersionHeadingIndex, 0, ...newSectionTokens);\n  }\n\n  render() {\n    if (!this.tokens) {\n      throw new Error('Tokens have not been loaded yet!');\n    }\n    return Markdown.render(this.tokens);\n  }\n}\n\n/**\n * Convenient method creating `Changelog` instance.\n */\nexport function loadFrom(path: string): Changelog {\n  return new Changelog(path);\n}\n\n/**\n * Parses given text and returns the first found semver version, or null if none was found.\n * If given text equals to unpublished version name then it's returned.\n */\nfunction parseVersion(text: string): string | null {\n  if (text === UNPUBLISHED_VERSION_NAME) {\n    return text;\n  }\n  const match = semverRegex().exec(text);\n  return match?.[0] ?? null;\n}\n\n/**\n * Parses given text and returns group name if found, null otherwise.\n */\nfunction parseGroup(text: string): string | null {\n  const match = /^\\*\\*`([@\\w\\-\\/]+)`\\*\\*/.exec(text.trim());\n  return match?.[1] ?? null;\n}\n\n/**\n * Checks whether given token is interpreted as a token with a version.\n */\nfunction isVersionToken(token: Markdown.Token, version?: string): token is Markdown.HeadingToken {\n  return (\n    Markdown.isHeadingToken(token) &&\n    token.depth === VERSION_HEADING_DEPTH &&\n    (!version || token.text === version || parseVersion(token.text) === version)\n  );\n}\n\n/**\n * Checks whether given token is interpreted as a token with a change type.\n */\nfunction isChangeTypeToken(\n  token: Markdown.Token,\n  changeType?: ChangeType | string\n): token is Markdown.HeadingToken {\n  return (\n    Markdown.isHeadingToken(token) &&\n    token.depth === CHANGE_TYPE_HEADING_DEPTH &&\n    (!changeType || token.text === changeType)\n  );\n}\n\n/**\n * Checks whether given token is interpreted as a list group.\n */\nfunction isGroupToken(token: Markdown.Token, groupName: string): token is Markdown.ListItemToken {\n  if (Markdown.isListItemToken(token) && token.depth === GROUP_LIST_ITEM_DEPTH) {\n    const firstToken = token.tokens[0];\n    return Markdown.isTextToken(firstToken) && parseGroup(firstToken.text) === groupName;\n  }\n  return false;\n}\n\n/**\n * Finds list item that makes a group with given name.\n */\nfunction findOrCreateGroupList(list: Markdown.ListToken, group: string): Markdown.ListToken {\n  let groupListItem = list.items.find((item) => isGroupToken(item, group)) ?? null;\n\n  // Group list item not found, create new list item token and add it at the end.\n  if (!groupListItem) {\n    groupListItem = Markdown.createListItemToken(getGroupLabel(group));\n    list.items.push(groupListItem);\n  }\n\n  // Find group list among list item tokens.\n  let groupList = groupListItem.tokens.find(Markdown.isListToken);\n\n  if (!groupList) {\n    groupList = Markdown.createListToken(GROUP_LIST_ITEM_DEPTH);\n    groupListItem.tokens.push(groupList);\n  }\n  return groupList;\n}\n\n/**\n * Stringifies change entry object.\n */\nexport function getChangeEntryLabel(entry: ChangelogEntry): string {\n  const pullRequests = entry.pullRequests || [];\n  const authors = entry.authors || [];\n\n  if (pullRequests.length + authors.length > 0) {\n    const pullRequestsStr = pullRequests\n      .map((pullRequest) => `[#${pullRequest}](https://github.com/expo/expo/pull/${pullRequest})`)\n      .join(', ');\n\n    const authorsStr = authors\n      .map((author) => `[@${author}](https://github.com/${author})`)\n      .join(', ');\n\n    const pullRequestInformations = `${pullRequestsStr} by ${authorsStr}`.trim();\n    return `${entry.message} (${pullRequestInformations})`;\n  }\n  return entry.message;\n}\n\n/**\n * Converts plain group name to its markdown representation.\n */\nfunction getGroupLabel(groupName: string): string {\n  return `**\\`${groupName}\\`**`;\n}\n\nfunction textToChangelogEntry(text: string): ChangelogEntry {\n  const pullRequests = execAll(\n    /\\[#\\d+\\]\\(https?:\\/\\/github\\.com\\/expo\\/expo\\/pull\\/(\\d+)\\)/g,\n    text,\n    1\n  );\n  const authors = execAll(/\\[@\\w+\\]\\(https?:\\/\\/github\\.com\\/([^/)]+)\\)/g, text, 1);\n\n  return {\n    message: text.trim(),\n    pullRequests: pullRequests.map((match) => parseInt(match, 10)),\n    authors,\n  };\n}\n"]}